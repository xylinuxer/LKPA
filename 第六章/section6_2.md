## 6.2 系统调用基本概念

系统调用实质就是函数调用，只是调用的函数是系统函数，处于内核态而已。用户在调用系统调用时会向内核传递一个系统调用号，然后系统调用处理程序通过此号从系统调用表中找到相应的内核函数执行（系统调用服务例程），最后返回。在这个过程中涉及到系统调用号、系统调用表以及系统调用处理程序等概念，本小节将介绍这些基本概念。

### 6.2.1 系统调用号

Linux系统有几百个系统调用，为了唯一的标识每一个系统调用，Linux为每一个系统调用定义了一个唯一的编号，此编号称为系统调用号。它定义在文件linux/arch/x86/include/asm/unistd_32.h中（注意，在不同的版本中，这个头文件的位置稍有不同）：
```c
#define __NR_restart_syscall 0

#define __NR_exit 1

#define __NR_fork 2

#define __NR_read 3

.……

#define __NR_fallocate 324
```
由此可见当前系统拥有324个系统调用。系统调用号的另一个目的是作为系统调用表的下标，当用户空间的进程执行一个系统调用的时候，这个系统调用号就被用来指明到底是要执行那个系统调用。系统调用号相当关键，一旦分配好就不能再有任何改变，否则编译好的应用程序就会因为调用到错误的系统调用而导致程序崩溃。

### 6.2.2 系统调用表

为了把系统调用号与相应的服务例程关联起来，内核利用了一个系统调用表，这个表存放在sys_call_table数组中，它是一个函数指针数组，每一个函数指针都指向了其系统调用的封装例程，有NR_syscalls个表项，第n个表项包含系统调用号为n的服务例程的地址。NR_syscalls宏只是对可实现的系统调用最大个数的静态限制，并不表示实际已实现的系统调用个数。这样我们就可以利用系统调用号作为下标，找到其系统调用的封装例程。此表定义在文件linux/arch/x86/kernel/syscall_table_32.S
```c
ENTRY(sys_call_table)

.long sys_restart_syscall /* 0 - old "setup()" system call, used for restarting */

.long sys_exit

.long sys_fork

.long sys_read

.long sys_write

.long sys_open /* 5 */

..……
```
### 6.2.3 系统调用服务例程和系统调用处理程序

每一个系统调用bar()在内核态都有一个对应的内核函数sys_bar()，这个内核函数就是系统调用bar()的实现，也就是说在用户态调用bar()，最终会由内核函数sys_bar()为用户服务，这就是系统调用服务例程。

系统调用既然最终会由相应的内核函数完成，那么为什么不直接调用内核函数呢？这是因为用户空间的程序无法直接执行内核代码，因为内核驻留在受保护的地址空间上，不允许用户进程在内核地址空间上读写。所以，应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，这种通知内核的机制是靠软中断来实现的，通过引发一个异常来促使系统切换到内核态去执行异常处理程序，此时的异常处理程序就是所谓的系统调用处理程序，下一节会接着介绍此程序。
