# **第二章 内存寻址**

&emsp;&emsp;我们知道，操作系统是一组软件的集合。但它和一般软件不同，因为它是充分挖掘硬件潜能的软件，也可以说，操作系统是横跨软件和硬件的桥梁。因此，要想深入解析操作系统内在的运作机制，就必须搞清楚相关的硬件机制——尤其是内存寻址的硬件机制。

&emsp;&emsp;操作系统的设计者必须在硬件相关的代码与硬件无关的代码之间划出清楚的界限，以便于一个操作系统很容易地移植到不同的平台。Linux的设计就做到了这点，它把与硬件相关的代码全部放在arch(architecture一词的缩写，即体系结构相关)的目录下，在这个目录下，可以找到Linux目前版本支持的所有平台，例如，支持的平台有arm、alpha,、i386、m68k、mips等十多种。在这众多的平台中，大家最熟悉的就是i386，即Intel80x86体系结构。因此，我们所介绍的内存寻址也是以此为背景。

## **2.1&emsp;内存寻址**

&emsp;&emsp;曾经有一个叫“阿兰.图灵”的天才1，它设想出了一种简单但运算能力几乎无限发达的理想机器，这不是一个具体的机械设备，而是一个思想模型，可以用来计算能想象得到的所有可计算函数。这个有趣的机器由一个控制器，一个读写头和一条假设两端无限长的带子组成。工作带相当于存储器，被划分成大小相同的格子，每格上可写一个字母，读写头可以在工作带上随意移动，而控制器可以要求读写头读取其下方工作带上的字母。

&emsp;&emsp;这听起来仅仅是纸上谈兵，但它却是当代冯.诺依曼计算机体系的理论鼻祖。它带来的“数据连续存储和选择读取思想”是目前我们使用的几乎所有机器运行背后的灵魂。计算机体系结构中的核心问题之一就是如何有效地进行内存寻址，因为所有运算的前提都是先要从内存中取得数据，所以内存寻址技术从某种程度上代表了计算机技术。
&emsp;&emsp;据说他16岁开始研究相对论，虽然英年早逝，但才气纵横逻辑学、物理学、数学等多个领域，尤其是数学逻辑上的所作所为奠定了现代计算技术的理论基础 。后来以他名字命名的“图灵奖”被看作计算机学界的最高荣誉。

### **2.1.1 &emsp;Intel X86 CPU寻址的演变**

&emsp;&emsp;在微处理器的历史上，第一款微处理器芯片4004是由Intel推出的，那是一个4位的微处理器。在4004之后，intel推出了一款8位处理器8080，它有1个主累加器（寄存器A）和6个次累加器（寄存器B,C,D,E,H和L）,几个次累加器可以配对（如组成BC, DE或HL）用来访问16位的内存地址，也就是说8080可访问到64K内的地址空间。另外，那时还没有段的概念，访问内存都要通过绝对地址，因此程序中的地址必须进行硬编码（给出具体地址），而且也难以重定位，这就不难理解为什么当时的软件大都是些可控性弱,结构简陋，数据处理量小的工控程序了。

&emsp;&emsp;几年后，intel开发出了16位的处理器8086，这个处理器标志着Intel X86王朝的开始，这也是内存寻址的第一次飞跃。之所以说这是一次飞跃，是因为8086处理器引入了一个重要概念—段

&emsp;&emsp;8086处理器的寻址目标是1M大的内存空间，于是它的地址总线扩展到了20位。但是，一个问题摆在了Intel设计人员面前，虽然地址总线宽度是20位的，但是CPU中“算术逻辑运算单元（ALU）”的宽度，即数据总线却只有16位，也就是可直接加以运算的指针长度是16位的。如何填补这个空隙呢？可能的解决方案有多种，例如，可以像一些8位CPU中那样，增设一些20位的指令专用于地址运算和操作，但是那样又会造成CPU内存结构的不均匀。又例如，当时的PDP－11小型机也是16位的，但是其内存管理单元（MMU）可以将16位的地址映射到24位的地址空间。受此启发，Intel设计了一种在当时看来不失为巧妙的方法，即分段的方法。 在微处理器的历史上，第一款微处理器芯片4004是由Intel推出的，那是一个4位的微处理器。在4004之后，intel推出了一款8位处理器8080，它有1个主累加器（寄存器A）和6个次累加器（寄存器B,C,D,E,H和L）,几个次累加器可以配对（如组成BC, DE或HL）用来访问16位的内存地址，也就是说8080可访问到64K内的地址空间。另外，那时还没有段的概念，访问内存都要通过绝对地址，因此程序中的地址必须进行硬编码（给出具体地址），而且也难以重定位，这就不难理解为什么当时的软件大都是些可控性弱,结构简陋，数据处理量小的工控程序了。

&emsp;&emsp;几年后，intel开发出了16位的处理器8086，这个处理器标志着Intel X86王朝的开始，这也是内存寻址的第一次飞跃。之所以说这是一次飞跃，是因为8086处理器引入了一个重要概念—段

&emsp;&emsp;为了支持分段，Intel在8086 CPU中设置了四个段寄存器：CS、DS、SS和ES，分别用于可执行代码段、数据段、堆栈段及其他段。每个段寄存器都是16位的，对应于地址总线中的高16位。每条“访内”指令中的内部地址也都是16位的，但是在送上地址总线之前，CPU内部自动地把它与某个段寄存器中的内容相加。因为段寄存器中的内容对应于20位地址总线中的高16位(也就是把段寄存器左移4位)，所以相加时实际上是内存总线中的高12位与段寄存器中的16位相加，而低4位保留不变，这样就形成一个20位的实际地址，也就实现了从16位内存地址到20位实际地址的转换，或者叫**“映射”**。

&emsp;&emsp;段式内存管理带来了显而易见的优势，程序的地址不再需要硬编码了，调试错误也更容易定位了，更可贵的是支持更大的内存地址。程序员开始获得了自由。

&emsp;&emsp;技术的发展不会就此止步。intel的80286处理器于1982年问世了，它的地址总线位数增加到了24位，因此可以访问到16M的内存空间。更重要的是从此开始引进了一个全新理念—**保护模式**。这种模式下内存段的访问受到了限制。访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查（从此你不能再随意存取数据段,具体保护和实现我们后面讲述）。

&emsp;&emsp;为了和过去兼容，80286内存寻址可以有两种方式，一种是先进的保护模式，另一种是老式的8086方式，被成为**实模式**。系统启动时处理器处于实模式，只能访问1M空间，经过处理可进入保护模式，访问空间扩大到16M，但是要想从保护模式返回到实模式，你只有重新启动机器。还有一个致命的缺陷是80286虽然扩大了访问空间，但是每个段的大小还是64k，程序规模仍受到限制。因此这个先天低能儿注定命不会很久。很快它就被天资卓越的兄弟——80386代替了。

&emsp;&emsp;80386是一个32位的CPU，也就是它的ALU数据总线是32位的，同时它的地址总线与数据总线宽度一致，也是32位，因此，其寻址能力达到4GB。对于内存来说，似乎是足够了。从理论上说，当数据总线与地址总线宽度一致时，其CPU结构应该简洁明了。但是，80386无法做到这一点。作为X86产品系列的一员，80386必须维持那些段寄存器的存在，还必须支持实模式，同时又要能支持保护模式，这给Intel的设计人员带来很大的挑战。

&emsp;&emsp;Intel选择了在段寄存器的基础上构筑保护模式，并且保留段寄存器16位。在保护模式下,它的段范围不再受限于64K，可以达到4G（参见段机制一节）。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。

&emsp;&emsp;从8086的16位到80386的32位处理器，这看起来是处理器位数的变化，但实质上是处理器体系结构的变化，从寻址方式上说，就是从“实模式”到“保护模式”的变化。从80386以后，Intel的CPU经历了80486、Pentium、PentiumII、PentiumIII等型号，虽然它们在速度上提高了好几个数量级，功能上也有不少改进，但基本上属于同一种系统结构的改进与加强，而无本质的变化，所以我们把80386以后的处理器统称为**80x86**。

### **2.1.2    &emsp; 80X86寄存器简介**

&emsp;&emsp;80386作为80X86系列中的一员，必须保证向后兼容，也就是说，既要支持16位的处理器，也要支持32位的处理器。在8086中，所有的寄存器都是16位的，我们来看一下80x86中寄存器有何变化：



- 	把16位的通用寄存器、标志寄存器以及指令指针寄存器扩充为32位的寄存器

- 	段寄存器仍然为16位。

- 	增加4个32位的控制寄存器

- 	增加4个系统地址寄存器

- 	增加8个调式寄存器

- 	增加2个测试寄存器

&emsp;&emsp;下面介绍几种常用的寄存器。

**1.通用寄存器**

&emsp;&emsp;8个通用寄存器是8086寄存器的超集，它们分别为：EAX ，EBX ，ECX ，EDX ，EBP ，EBP， ESI及 EDI。这8个通用寄存器中通常保存32位数据，但为了进行16位的操作并与16为机保持兼容，它们的低位部分被当成8个16位的寄存器，即AX、BX…DI。为了支持8位的操作，还进一步把EAX、EBX、ECX、EDX这四个寄存器低位部分的16位，再分为8位一组的高位字节和低位字节两部分，作为8个8位寄存器。这8个寄存器分别被命名为AH、BH、CH、DH和AL、BL、CL、DL。因此，这8个通用寄存器既可以支持1位、8位、16位和32位数据运算，也支持16位和32位存储器寻址。

**2. 段寄存器**

&emsp;&emsp;8086中有4个16位的段寄存器：CS、DS、SS、ES，分别用于存放可执行代码的代码段、数据段、堆栈段和其他段的基地址。在80x86中，有6个16位的段寄存器，但是，这些段寄存器中存放的不再是某个段的基地址，而是某个段的选择符（Selector）。因为16位的寄存器无法存放32位的段基地址，段基地址只好存放在一个叫做描述符表（Descriptor）的表中。因此，在80x86中，我们把段寄存器叫做选择符。有关段选择符、描述符表将在段机制一节进行描述。

**3.指令指针寄存器和标志寄存器**

&emsp;&emsp;指令指针寄存器EIP中存放下一条将要执行指令的偏移量（offset ），这个偏移量是相对于目前正在运行的代码段寄存器CS而言的。偏移量加上当前代码段的基地址，就形成了下一条指令的地址。EIP中的低16位可以被单独访问，给它起名叫指令指针IP寄存器，用于16位寻址。标志寄存器EFLAGS存放有关处理器的控制标志，很多标志与16位FLAGS中的标志含义一样。 

**4．控制寄存器**

&emsp;&emsp;80x86有四个32位的控制寄存器，它们是CR0，CR1，CR2和CR3，主要用于操作系统的分页机制（参见下节）。其结构如图 2.1所示。

![](http://i.imgur.com/5DMLAKS.png)
 
&emsp;&emsp;这几个寄存器中保存全局性和任务无关的机器状态。

&emsp;&emsp;CR0中包含了6个预定义标志，这里介绍内核中主要用到的0位和31位。0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。CR0的第31位是分页允许位(Paging Enable)，它表示芯片上的分页部件是否被允许工作。由PG位和PE位定义的操作方式如图2.2所示。

![](http://i.imgur.com/5c48Tlq.png)	

&emsp;&emsp;使用以下代码就可以允许分页（AT＆T汇编语言参考2.5节）：

    movl %cr0, %eax
    orl  $0x80000000, %eax
    movl %eax, %cr0

&emsp;&emsp;CR1是未定义的控制寄存器，供将来的处理器使用。

&emsp;&emsp;CR2是缺页线性地址寄存器，保存最后一次出现缺页的全32位线性地址（将在内存管理一章介绍）。

&emsp;&emsp;CR3是页目录基址寄存器，保存页目录的物理地址，页目录总是放在以4K字节为单位的存储器边界上，因此，其地址的低12位总为0，不起作用，即使写上内容，也不会被理会。

&emsp;&emsp;这几个寄存器是与分页机制密切相关的，因此，在后面分页机制和第四章虚拟内存管理中会涉及到，读者要记住CR0、CR2及CR3这三个寄存器的作用。 
### **2.1.3 &emsp;物理地址、虚拟地址及线性地址**

&emsp;&emsp;在硬件工程师和普通用户看来，内存就是插在或固化在主板上的内存条，它们有一定的容量，比如128MB。但在应用程序员看来中，并不过度关心插在主板上的内存容量，而是他们可以使用的内存空间，比如，他们可以开发一个占用1 GB内存的程序，并让其在操作系统下运行，哪怕这台机器上只有128 MB的物理内存条。而对于操作系统开发者而言，则是介于二者之间，它既需要知道物理内存的地址，也需要提供一套机制，为应用程序员提供另一个内存空间，这个内存空间的大小可以和实际的物理内存大小之间没有多大关系。

&emsp;&emsp;我们将主板上的物理内存条所提供的内存空间定义为物理内存空间，其中每个内存单元的实际地址就是物理地址；将应用程序员看到的内存空间2定义为虚拟地址空间(或地址空间)，其中的地址就叫虚拟地址(或逻辑地址)， 一般用“段：偏移量”的形式来描述，比如在8086中A815:CF2D就代表段首地址为A815，段内偏移位为CF2D的虚地址。
> 2 因为高级语言不涉及内存空间，因此，这里指的是从汇编语言的角度看。

&emsp;&emsp;线性地址空间是指一段连续的，不分段的，范围为0到4GB的地址空间，一个线性地址就是线性地址空间的一个绝对地址。

&emsp;&emsp;那么，这几种地址之间如何转换？例如，当程序执行“mov  ax，[1024]”这样一条指令时，在8086的实模式下，把某一段寄存器(比如ds)左移4位，然后与16位的偏移量(1024)相加后被直接送到内存总线上，这个相加后的地址就是内存单元的物理地址，而程序中的地址（例如ds:1024）就叫虚拟地址。在80X86保护模式下，这个虚拟地址不是被直接送到内存总线，而是被送到内存管理单元（MMU）。MMU由一个或一组芯片组成，其功能是把虚拟地址映射为物理地址，即进行地址转换，如图2.3所示。
![](http://i.imgur.com/0mpJQxn.png)

&emsp;&emsp;其中，MMU是一种硬件电路，它包含两个部件，一个是分段部件，一个是分页部件，在本书中，我们把它们分别叫做分段机制和分页机制，以利于从逻辑的角度来理解硬件的实现机制。分段机制把一个虚拟地址转换为线性地址；接着，分页机制把一个线性地址转换为物理地址，如图2.4所示。

![](http://i.imgur.com/AjpT74k.png)

&emsp;&emsp;下一节对段机制和分页机制进行具体介绍。
