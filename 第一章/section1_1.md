## **1.1  认识操作系统**
&emsp;&emsp;从使用者的角度看，操作系统使得计算机易于使用。从程序员的角度看，操作系统把软件开发人员从与硬件打交道的繁琐事务中解放出来。从设计者的角度看，有了操作系统，就可以方便的对计算机系统中的各种软硬件资源进行有效的管理。


### **1.1.1 从使用者角度看**

&emsp;&emsp;我们对操作系统的认识一般是从使用开始的。打开计算机，呈现在眼前的首先是操作系统。如果用户打开的是操作系统字符界面，就可以通过命令完成需要的操作，例如在Linux下拷贝一个文件

    cp  /home/TEST  /mydir/test

上述命令可以把/home目录下的TEST文件拷贝到mydir目录下，并更名为test。

&emsp;&emsp;为什么我们可以这么轻而易举地拷贝文件？操作系统从中做了什么？首先，文件这个概念是从操作系统中衍生出来的。如果没有文件这个实体，我们就必须指明数据存放的物理位置，例如，哪个柱面，哪个扇区。其次，数据搬动过程是复杂的I/O操作，一般用户无法关注这些具体的细节。最后，这个命令的执行还涉及其他复杂的操作，但是，有了操作系统，用户只需要知道文件名，其它繁琐的事务完全由操作系统去处理。

&emsp;&emsp;如果用户在图形界面下操作，上述处理就更加容易，只需点击鼠标就可以完成需要的操作。实际上，图形界面的本质也是执行各种命令，例如，如果是拷贝一个文件，那么就要调用cp命令，而具体的拷贝操作最终还是由操作系统去完成。

&emsp;&emsp;因此，不管是敲击键盘或者是点击鼠标，这些简单的操作指挥计算机完成着复杂的处理过程。正是操作系统，把繁琐留给自己，简单留给用户。

### **1.1.2 从程序开发者的角度看**

&emsp;&emsp;从程序开发者的角度看，开发者不用关心如何在内存存放变量、数据，如何从外存存取数据，如何把数据在输出设备上显示出来等等。例如在Linux下实现cp命令的C语言片段为：

    inf = open("/home/TEST", O_RDONLY);
    outf = open("/mydir/test", O_WRONLY);
    do{
	    len = read(inf, buf, 4096);
	    write(outf, buf, len);
    } while(len);
    close(inf);
    close(outf);

&emsp;&emsp;在这段程序中，涉及到四个函数open(), close(),write()和read()，这些都是C语言函数库中的函数。进一步追究，这些函数都要涉及I/O操作，因此，它们的实现必须调用操作系统所提供的接口，也就是说，打开文件、关闭文件、读写文件的具体实现是由操作系统完成的。这些操作非常繁琐，操作系统不同，其具体实现可能不同。

### **1.1.3 从操作系统在整个计算机系统所处位置看**
&emsp;&emsp;如果把操作系统放在整个计算机系统中看，则如图1.1所示：

![](http://i.imgur.com/YbpnIM0.png)

&emsp;&emsp;因为操作系统这个术语越来越大众化，因此许多用户把他们在显示器屏幕上看到的东西理所当然的认为就是操作系统，例如认为图形界面、浏览器、系统工具集等都算操作系统的一部分。但是，本书讨论的操作系统是指内核（Kernel）。用户界面是操作系统的外在表象，内核是操作系统的内在核心，它真正完成用户程序所要求的操作。

&emsp;&emsp;从图1.1可以看出，**一方面操作系统是上层软件与硬件打交道的窗口和桥梁，另一方面操作系统是其它所有用户程序运行的基础。**

&emsp;&emsp;下面从一个程序的执行过程，我们看一下操作系统起什么样的作用。一个简单的C程序如下，其名为**test.c**：

    #include <stdio.h>
    main()
    {
	    printf(" Hello world\n");
	    return 0;
    }
&emsp;&emsp;用户对这个程序编译并连接:

    gcc test.c –o test

&emsp;&emsp;于是形成一个可执行的二进制文件test，在Linux 下执行该程序./test

&emsp;&emsp;执行过程简述如下:

1.	用户告诉操作系统执行test
2.	操作系统通过文件名在磁盘找到该程序
3.	检查可执行代码首部，找出代码和数据存放的地址
4.	文件系统找到第一个磁盘块
5.	操作系统建立程序的执行环境
6.	操作系统把程序从磁盘装入内存，并跳到程序开始处执行
7.	操作系统检查字符串的位置是否正确
8.	操作系统找到字符串被送往的设备
9.	操作系统将字符串送往输出设备窗口系统确定这是一个合法的操作，然后将字符串转换成像素
10.	窗口系统将像素写入存储映像区
11.	视频硬件将像素表示转换成一组模拟信号控制显示器（重画屏幕）
12.	显示器发射电子束。你在屏幕上看到Hello world。

&emsp;&emsp;从这个简单的例子可以看出，任何一个程序的运行只有借助于操作系统才能得以顺利完成，因此，从本质上说,**操作系统是应用程序的运行环境。**
 
### **1.1.4 从操作系统设计者的角度看**

&emsp;&emsp;操作系统是一个庞大复杂的系统软件。其设计目标有两个，一是尽可能地方便用户使用计算机，二是让各种软件资源和硬件资源高效而协调地运转起来。

&emsp;&emsp;笼统地说，计算机的硬件资源包括CPU、存储器和各种外设，其中外设种类繁多，如磁盘、鼠标、网络接口、打印机等，操作系统对外设的操作是通过I/O接口进行的。软件资源主要指存放在存储介质上的文件。

&emsp;&emsp;假设在一台计算机上有三道程序同时运行，并试图在一台打印机上输出运算结果，这意味着必须考虑以下问题：

（1）三道程序在内存中如何存放？

（2）什么时候让某个程序占用CPU？

（3）怎样有序地输出各个程序的运算结果？

&emsp;&emsp;对这些问题的解决都必须求助于操作系统，也就是说操作系统必须对内存进行管理，对CPU进行管理，对外设进行管理，对存放在磁盘上的文件更是要精心组织和管理，不仅如此，操作系统对这些资源进行管理的基础上，还要给用户提供良好的接口，以便用户能在某种程度上使用或者操纵这些资源。

&emsp;&emsp;因此，从操作系统设计者的角度考虑，一个操作系统必须包含以下几部分：

1)	操作系统接口

2)	CPU管理

3)	内存管理

4)	设备管理

5)	文件管理

&emsp;&emsp;以上这几大管理功能，因具体操作系统不同而稍有取舍，但Linux具备了以上所有的管理功能。

### **1.1.5  操作系统组成**

&emsp;&emsp;尽管我们从不同角度初步认识了操作系统这一概念，但日常应用中，操作系统一词已经有很多不同的内涵。操作系统通常被认为是整个系统中负责完成最基本功能和系统管理的部分。除了内核，这些部分还应当包括启动引导程序、命令行shell或者其他种类的用户界面、基本的文件管理工具和系统工具等。

&emsp;&emsp;可是，由于大多数最终用户是通过商业途径得到操作系统，他们很少会仅仅购买一个只包含以上功能的软件包。一般地，他们在得到操作系统的同时，更需要的是构架于其上的应用软件，从而完成所需的实际功能。为了满足这种需求，操作系统一般要和应用软件绑定发行和出售。这样的软件包在Linux领域被称作发布版。

&emsp;&emsp;由此就引起了一些误解，许多用户理所当然地认为发布版就是操作系统。但是，从逻辑结构划分，发布版中的很多应用软件不应该属于操作系统。

&emsp;&emsp;为了符合大多数人的习惯，在本书中，我们一般用操作系统这个词指代发布版，而用内核表示操作系统本来的逻辑概念。在不引起混淆的情况下，有时也会用操作系统表示内核。

&emsp;&emsp;操作系统本质上也是大型软件包（从开发者的角度看），因此结构组织也不会与其它大型软件迥然而异：操作系统的设计采取分层结构，越向上层抽象程度越高，越接近用户；相反，越向下层，越靠近硬件，抽象也相对接近硬件。另外，上层软件依靠下层软件提供的服务，而且上层软件本身还提供附加服务，因此，操作系统的结构总体呈现倒金子塔形。

&emsp;&emsp;不同的操作系统，其组成结构不尽相同。我们选取Unix/Linux操作系统作为背景,至于各种操作系统之间的具体差异，读者可以对比下面的公式之后形成自己的认识。
    
&emsp;&emsp;我们用一组简单的公式来描述操作系统的组成要素：

操作系统 = 内核 + 系统程序

系统程序 = 编译环境 ＋ API（应用程序接口）+AUI（用户接口）

编译环境 ＝ 编译程序 ＋ 连接程序 ＋ 装载程序

API  = 系统调用 ＋ 语言库函数（C、C++、Java等等）

AUI  =  shell + 系统服务例程（如x服务器等）+ 应用程序(浏览器，字处理，编辑器等) 

&emsp;&emsp;而整个软件系统是：

软件系统 = 操作系统 + AUI

操作系统最底层的组件是内核，其上层搭建了许多系统程序。

系统程序包括三个部分，分别是：编译环境、应用程序接口和用户接口。

&emsp;&emsp;编译环境包含汇编、C 等低高级语言编译程序，连接程序和装载程序，这些程序负责将文本格式的程序语言转变为机器能识别和装载的机器代码。

&emsp;&emsp;应用程序接口（API）包含内核提供的系统调用接口和语言库，系统调用是为了能让应用程序使用内核提供的服务，语言库函数则是为了方便应用程序开发，所以将一些常用的基础功能预先编译以供使用，比如对C语言来说有常用的C库等；

&emsp;&emsp;用户接口(AUI)包括我们熟悉的shell、系统服务程序和常用的应用程序。

&emsp;&emsp;这是一个典型的结构，但不是一成不变。许多操作系统的发行版中会有所删减，比如应用于嵌入式设备的系统，对X服务器就可能不做要求。但是像内核、系统调用等要素是必不可少的。

&emsp;&emsp;关于系统软件在此给予进一步说明。系统软件是相对应用软件而言的，应用软件针对最终用户需求编写，完成实际功能，而系统软件则是为了简化应用程序的开发而存在的，比如数据库系统为应用软件提供了有效的数据传输、存储服务；还有编程语言的执行环境（它由C库实现），也属于一种系统程序，它为应用程序开发提供了诸如I/O操作例程，图形库，计算库等等基础服务。可见系统软件范围覆盖很广，只要面向的服务群体不是最终用户的软件都可以划归到系统软件中。

